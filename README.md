# üïä Dove
## üî¢ Basics
Put simply, **Dove** is a balanced network, 128-bit block, 256-bit key, configurable round count block cipher.
Although it was created mostly for educational purposes, I think that the general cipher with a good enough
round count can be used in production (*the current reference implementation may not be fully optimized, however*).

The current implementation is also a bit low-level, as it does not implement any modes of operation, and relies on
the user to implement them themselves (*this will not be the case in the future*).

## üè´ Short tutorial
In short, whenever the **Dove** library asks for a:
 - `key`, it expects it to point to a 32-byte value, preferably aligned to an 8-byte boundary
 - `keychain`, it expects it to point to an array of 32-byte values, again, preferably aligned to an 8-byte boundary, that is `rounds` bytes long
 - `block`, it expects it to point to an array of 16 bytes, preferably aligned to an 8-byte boundary, that contains the plaintext/ciphertext that will be converted into ciphertext/plaintext
These values need not be aligned to 8-byte boundaries, but a downgrade in performance is to be expected.

### ‚ùî Function rundown
As **Dove** uses a different key each round, the keys need to first be generated before any operation can be performed.
To generate a keychain out of a given key, simply call `dove_init_keychain` with your key, your soon-to-be keychain, and
the number of rounds you desire to operate for.

To encrypt or decrypt, intuitively, call `dove_encrypt` or `dove_decrypt` respectively. Both of these functions take the same paraemeters,
a keychain, a block and a number of rounds (*note that the blocks are both inputs and outputs to the function*).

### üìú A basic example
Below is an example of a pair of encryption and decryption operations, as well as key generations
```c
#include <stdio.h>
#include <stdint.h>
#include <crypt/dove.h>

#define NUM_ROUNDS (16)

int main(void) {
    // Our key is just 256 bits of zeroes
    const uint8_t key[32] = { 0 };
    uint8_t keychain[32 * NUM_ROUNDS];

    // Initialize our keychain
    dove_init_keychain(key, keychain, NUM_ROUNDS);

    // This is what we'll be hiding from people today
    uint8_t block[16] = "What a nice day!";
    printf("%.*s\n", 16, block);

    // Now nobody will know what a day it is
    dove_encrypt(keychain, block, NUM_ROUNDS);

    // Well, now everyone will
    dove_decrypt(keychain, block, NUM_ROUNDS);
    printf("%.*s\n", 16, block);
    return 0;
}
```

## ü§® How the algorithm works
**Dove** is a balanced Feistel network cipher, meaning that every round, it hashes the right side of its block, x-ors the left side with the hash and switches them around.
Note that you don't have to read this, it is just information with which you can implement dove yourself, if that's what you want.

Things to note:
- The ***s-box*** is created from the first 2048 hex digits of euler's constant, after the decimal point
- The ***offsetting constant*** is simply the first 16 hex digits of the natural logarithm of two, after the decimal point

(*digits for the two aforementioned constants in this implementation were sourced from [here](http://www.numberworld.org/constants.html)*)

### üî™ Hash function
The hash function takes a 64-bit value and a 256-bit key as input and returns a new pseudorandom 64-bit value.

The hash function does these steps in order:
1. Divide the block into 2 32-bit words
2. For the two words, take every byte of them through the ***s-box*** and sum them into two 32-bit sums (*one for each word*)
3. Combine the two sums into a new 64-bit word and x-or it with the first 64 bits of the key
4. Interlace the new word (*basically, move all even bytes to the left and all odd bytes to the right, by index which starts at 0, not by value*)
5. Split the word up and do step 2 again
6. Put the 64-bit word back and x-or it with the second 64 bits of the key
7. Split the 64-bit word up yet again, this time rotating the less significant side by 5 bits to the left, and the more significant side by 5 bits to the right
8. Do step 2 again
9. Put the word back and x-or it with the third 64 bits of the key
10. Do step 4 again, and then split up the word into two and do step 2 again
11. Then, put it back and x-or with the fourth and last 64 bits of the key
12. Add the ***offsetting constant***
13. Invert the result

### üîë Round key generation
Round keys are generated by first copying the initial key to be the key for round 1, and then generating every other key from the key that precedes it.

The round key generator follows the following steps:
1. Divide the old key into 8 32-bit words
2. For each word, make it the sum of each of its bytes passed through the ***s-box*** (*like in the hash function, but for 256 bits now*)
3. Combine the sums back together, and then interlace the first 16 bytes with each other as well as the last 16 bytes (*essentially, treat each 16 byte chunk as a 4x4 matrix and then [transpose](https://en.wikipedia.org/wiki/Transpose) them*)
4. Divide the key into 8 parts and do step 2 again
5. Now, combine them back and then split the key into 16 16-bit words, and interlace them (again, like in step 3, this is just a transpose of a 4x4 matrix)
6. Combine them back and do step 2 one last time

### üîê Encryption
As was previously mentioned, and in any standard Feistel network cipher, for every round simply split the block into two 64-bit halves, x-or the left half with the hash of the right half, and swap them (*the swapping step is ommited for the last round*).
In pseudo code (*F* is our hash function, *^* means x-or, *K* is the key for the current round and *L* and *R* are the left and right halves of the block):
```
L = L ^ F(R, K)

if not last round then
    L, R = R, L
endif
```
### üí° Decryption
Because **Dove** is a Feistel network, decryption is simply encryption, but done with the keys in reverse order. Simply loop from the round count to 0 and index the keychain array accordingly when hashing.

### üìù Final note
If this explanation is weird (*and, it probably is*), rest assured, I will eventually create a visualization of the hash function and the round key generation in the near future.

# ‚öñ Licensing
This implementation of **Dove** is licensed under the MIT license, which means that you can do virtually anything, but you **HAVE** to acknowledge that this is code that I wrote. **Dove** will always be in the public domain, and thus free for anyone to use or implement.